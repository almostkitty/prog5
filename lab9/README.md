
## Лабораторная работа #9
#### Пальчук Г.А. ИВТ 2.1

1. [Ход работы](#title2)
2. [Инструкция по запуску сервиса и взаимодействию с проектом](#title3)


-----

## <a id="title2">Отчёт о проделанной работе</a>

### Установлены следующие библиотеки:
> Flask==3.1.0
> 
> Flask-JWT-Extended==4.7.1
> 
> Flask-SQLAlchemy==3.1.1
> 
> Flask-migrate
> 
> PyJWT==2.10.1
> 
> SQLAlchemy==2.0.36
> 
> poetry==1.8.5

Выполнена начальная настрока poetry через команду `poetry init`


### Структура проекта:
> app/templates -- Директория с разметкой основных страниц
> 
> app/routes/main.py -- Файл с обработкой маршрутов
> 
> app/__init__.py -- Файл с подключением БД, JWT-Токена и миграцией
> 
> app/models.py -- Структура для БД
> 
> config.py -- Файл конфигурации
> 
> app.py -- Основной файл для запуска


## <a id="title3">Инструкция по запуску сервиса и взаимодействию с проектом</a>
1. Создание и активация виртуального окружения:

`python3 -m venv venv`

`source venv/bin/activate`

2. Установка зависимостей: `pip install -r requirements.txt`

3. Инициализация БД:

`flask db init`

`flask db migrate -m "Инициализация базы данных"`

`flask db upgrade`

4. Запуск: `flask --app app run`

5. Переходим по адресу: http://127.0.0.1:5000/
   
   Маршруты:
   Регистрация -- http://127.0.0.1:5000/register
   Вход в систему -- http://127.0.0.1:5000/login 


## Реализовано:

1. Метод /login, который выполняет аутентификацию пользователя с использованием логина и пароля.

Если пользователь успешно проходит аутентификацию, ему генерируется JWT токен с помощью фабрики token_factory. Этот токен используется для доступа к защищенным ресурсам.

В ответе также возвращается уровень бонусной программы пользователя, который хранится в базе данных.


2. Для проверки пароля используется метод `check_password_hash` из `werkzeug.security`.

Для создания токена используется функция `create_access_token` из библиотеки `flask_jwt_extended`.

Уровень бонуса пользователя передается из поля `bonus_level` в модели `User`.


3. Для защищенных маршрутов, таких как получение профиля пользователя, был использован декоратор `@jwt_required()`, который проверяет наличие и валидность JWT-токена в запросе. Токен проверяется при каждом запросе, и доступ к данным пользователя предоставляется только в случае правильной аутентификации.


4. В модели `User` добавлены поля для хранения уровня бонусной программы и суммы трат пользователя, что позволит отслеживать бонусы и обновлять их на основе активности пользователя.


5. Паттерн наблюдателя для обновления уровня бонуса пользователя на основе его трат. Для этого был создан класс `BonusObserver`, который отслеживает транзакции пользователя и изменяет его бонусный уровень в зависимости от потраченной суммы.